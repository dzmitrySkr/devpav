import { Fragment, useState } from "react";

function Keys() {

  const numbers = [1, 2, 3, 4, 5];

  return (
    <Fragment>
      <h2 className="article_title">Keys</h2>
      <p className="content">
        Ключи помогают React определять, какие элементы были изменены, добавлены
        или удалены. Их необходимо указывать, чтобы React мог сопоставлять
        элементы массива с течением времени:
      </p>

      <div className="example">
        <pre>
          {`
     const numbers = [1, 2, 3, 4, 5];
     const listItems = numbers.map((number) =>
       <li key={number.toString()}>
         {number}
       </li>
     );
                      `}
        </pre>
      </div>

      {numbers.map((number) =>
       <p key={number.toString()}>
         {number}
       </p>)}


       <p className="content">
         Выше реализация добавления уникального ключа при цикличном выводе элеменов
       </p>


      <p className="content">
        Лучший способ выбрать ключ — это использовать строку, которая будет явно
        отличать элемент списка от его соседей. Чаще всего вы будете
        использовать ID из ваших данных как ключи:
      </p>

      <div className="example">
        <pre>
          {`
    const todoItems = todos.map((todo) =>
    <li key={todo.id}>
      {todo.text}
    </li>
    );
                      `}
        </pre>
      </div>

      <p className="content">
        Ключи нужно определять непосредственно внутри массивов.
       </p>
       <p className="content">
        Если не указать ключи, в консоли увидим сообщение: Warning: Each child
        in an array or iterator should have a unique “key” prop.
        </p>
       <p className="content">
        Ключи оптимизируют работу с элементами массивов, уменьшают количество
        ненужных удалений и созданий элементов.
        </p>
       <p className="content">
        Без key механизм reconciliation сверяет компоненты попарно между текущим
        и новым VDOM. Из-за этого может происходить большое количество лишних
        перерисовок интерфейса, что замедляет работу приложения.
        </p>
       <p className="content">
        Добавляя key, вы помогаете механизму reconciliation тем, что с key он
        сверяет не попарно, а ищет компоненты с тем же key (тег / имя компонента
        при этом учитывается) — это уменьшает количество перерисовок интерфейса.
        Обновлены/добавлены будут только те элементы, которые были изменены/не
        встречались в предыдущем дереве.
        </p>
       <p className="content">
        Следите, чтобы не появлялись дублирующие key, при переключении
        отображения у новых данных не совпадали ключи. Это может привести к
        нежелательным сайд-эффектам, таким как анимации, или некорректной логике
        поведения элемента.
        </p>
       <p className="content">
        key и ref — специальные props. Они недоступны в компоненте, их нет в
        child.props. Можно получить доступ в родителе через child.key, но
        реальных областей применения для этого практически нет. Если в дочерних
        компонентах нужен key — правильным решением будет задублировать в prop
        id, например.
        </p>
       
    </Fragment>
  );
}

export default Keys;
